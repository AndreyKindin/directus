<template>
	<insights-not-found v-if="!currentDashboard" />
	<private-view v-else :title="currentDashboard.name">
		<template #title-outer:prepend>
			<v-button rounded disabled icon secondary>
				<v-icon :name="currentDashboard.icon" />
			</v-button>
		</template>

		<template #headline>
			<v-breadcrumb :items="[{ name: t('insights'), to: '/insights' }]" />
		</template>

		<template #actions>
			<template v-if="editMode">
				<v-button
					class="clear-changes"
					v-tooltip.bottom="t('clear_changes')"
					rounded
					icon
					outlined
					@click="cancelChanges"
				>
					<v-icon name="clear" />
				</v-button>

				<v-button rounded icon outlined v-tooltip.bottom="t('add_new')" :to="`/insights/${currentDashboard.id}/+`">
					<v-icon name="add" />
				</v-button>

				<v-button rounded icon v-tooltip.bottom="t('save')" @click="saveChanges" :loading="saving">
					<v-icon name="check" />
				</v-button>
			</template>

			<template v-else>
				<v-button :active="zoomToFit" class="zoom-to-fit" rounded icon outlined @click="toggleZoomToFit">
					<v-icon name="aspect_ratio" />
				</v-button>

				<v-button :active="fullScreen" class="fullscreen" rounded icon outlined @click="toggleFullScreen">
					<v-icon name="fullscreen" />
				</v-button>

				<v-button rounded icon outlined @click="editMode = !editMode">
					<v-icon name="edit" />
				</v-button>
			</template>
		</template>

		<template #navigation>
			<insights-navigation />
		</template>

		<div class="insights">
			<insights-workspace :edit-mode="editMode" :panels="panels" :zoom-to-fit="zoomToFit" />
		</div>

		<router-view
			name="detail"
			:dashboard-key="primaryKey"
			:panel="panels.find((panel) => panel.id === panelKey)"
			@save="stageConfiguration"
			@cancel="$router.push(`/insights/${primaryKey}`)"
		/>

		<v-dialog :model-value="!!confirmDeletePanel" @esc="confirmDeletePanel = null">
			<v-card>
				<v-card-title>{{ t('panel_delete_confirm') }}</v-card-title>

				<v-card-actions>
					<v-button @click="confirmDeletePanel = null" secondary>
						{{ t('cancel') }}
					</v-button>
					<v-button danger @click="deletePanel" :loading="deletingPanel">
						{{ t('delete') }}
					</v-button>
				</v-card-actions>
			</v-card>
		</v-dialog>
	</private-view>
</template>

<script lang="ts">
import InsightsNavigation from '../components/navigation.vue';
import { defineComponent, computed, ref, toRefs, inject } from 'vue';
import { useInsightsStore, useAppStore } from '@/stores';
import InsightsNotFound from './not-found.vue';
import { Panel } from '@/types';
import { nanoid } from 'nanoid';
import { merge, omit } from 'lodash';
import { router } from '@/router';
import { unexpectedError } from '@/utils/unexpected-error';
import api from '@/api';
import { useI18n } from 'vue-i18n';
import { pointOnLine } from '@/utils/point-on-line';
import InsightsWorkspace from '../components/workspace.vue';

export default defineComponent({
	name: 'InsightsDashboard',
	components: { InsightsNotFound, InsightsNavigation, InsightsWorkspace },
	props: {
		primaryKey: {
			type: String,
			required: true,
		},
		panelKey: {
			type: String,
			default: null,
		},
	},
	setup(props) {
		const { t } = useI18n();

		const insightsStore = useInsightsStore();
		const appStore = useAppStore();

		const { fullScreen } = toRefs(appStore);

		const editMode = ref(false);
		const confirmDeletePanel = ref<string | null>(null);
		const deletingPanel = ref(false);
		const saving = ref(false);

		const zoomToFit = ref(false);

		const currentDashboard = computed(() =>
			insightsStore.dashboards.find((dashboard) => dashboard.id === props.primaryKey)
		);

		const stagedPanels = ref<Partial<Panel & { borderRadius: [boolean, boolean, boolean, boolean] }>[]>([]);

		const panels = computed(() => {
			const savedPanels = currentDashboard.value?.panels || [];

			const raw = [
				...savedPanels.map((panel) => {
					const updates = stagedPanels.value.find((updatedPanel) => updatedPanel.id === panel.id);

					if (updates) {
						return merge({}, panel, updates);
					}

					return panel;
				}),
				...stagedPanels.value.filter((panel) => panel.id?.startsWith('_')),
			];

			const withCoords = raw.map((panel) => ({
				...panel,
				_coordinates: [
					[panel.position_x!, panel.position_y!],
					[panel.position_x! + panel.width!, panel.position_y!],
					[panel.position_x! + panel.width!, panel.position_y! + panel.height!],
					[panel.position_x!, panel.position_y! + panel.height!],
				] as [number, number][],
			}));

			const withBorderRadii = withCoords.map((panel) => {
				let topLeftIntersects = false;
				let topRightIntersects = false;
				let bottomRightIntersects = false;
				let bottomLeftIntersects = false;

				for (const otherPanel of withCoords) {
					if (otherPanel.id === panel.id) continue;

					const borders = [
						[otherPanel._coordinates[0], otherPanel._coordinates[1]],
						[otherPanel._coordinates[1], otherPanel._coordinates[2]],
						[otherPanel._coordinates[2], otherPanel._coordinates[3]],
						[otherPanel._coordinates[3], otherPanel._coordinates[0]],
					];

					if (topLeftIntersects === false)
						topLeftIntersects = borders.some(([p1, p2]) => pointOnLine(panel._coordinates[0], p1, p2));
					if (topRightIntersects === false)
						topRightIntersects = borders.some(([p1, p2]) => pointOnLine(panel._coordinates[1], p1, p2));
					if (bottomRightIntersects === false)
						bottomRightIntersects = borders.some(([p1, p2]) => pointOnLine(panel._coordinates[2], p1, p2));
					if (bottomLeftIntersects === false)
						bottomLeftIntersects = borders.some(([p1, p2]) => pointOnLine(panel._coordinates[3], p1, p2));
				}

				return {
					...panel,
					borderRadius: [!topLeftIntersects, !topRightIntersects, !bottomRightIntersects, !bottomLeftIntersects],
				};
			});

			return withBorderRadii;
		});

		return {
			currentDashboard,
			editMode,
			panels,
			stagePanelEdits,
			stagedPanels,
			saving,
			saveChanges,
			stageConfiguration,
			deletingPanel,
			deletePanel,
			confirmDeletePanel,
			cancelChanges,
			duplicatePanel,
			t,
			toggleFullScreen,
			zoomToFit,
			fullScreen,
			toggleZoomToFit,
		};

		function stagePanelEdits(edits: Partial<Panel>, key: string = props.panelKey) {
			if (key === '+') {
				stagedPanels.value = [
					...stagedPanels.value,
					{
						id: `_${nanoid()}`,
						dashboard: props.primaryKey,
						...edits,
					},
				];
			} else {
				if (stagedPanels.value.some((panel) => panel.id === key)) {
					stagedPanels.value = stagedPanels.value.map((panel) => {
						if (panel.id === key) {
							return merge({ id: key, dashboard: props.primaryKey }, panel, edits);
						}

						return panel;
					});
				} else {
					stagedPanels.value = [...stagedPanels.value, { id: key, dashboard: props.primaryKey, ...edits }];
				}
			}
		}

		function stageConfiguration(edits: Partial<Panel>) {
			stagePanelEdits(edits);
			router.push(`/insights/${props.primaryKey}`);
		}

		async function saveChanges() {
			if (!currentDashboard.value) return;

			if (stagedPanels.value.length === 0) {
				editMode.value = false;
				return;
			}

			saving.value = true;

			const currentIDs = currentDashboard.value.panels.map((panel) => panel.id);

			const updatedPanels = [
				...currentIDs.map((id) => {
					return stagedPanels.value.find((panel) => panel.id === id) || id;
				}),
				...stagedPanels.value.filter((panel) => panel.id?.startsWith('_')).map((panel) => omit(panel, 'id')),
			];

			try {
				await api.patch(`/dashboards/${props.primaryKey}`, {
					panels: updatedPanels,
				});

				await insightsStore.hydrate();

				stagedPanels.value = [];
				editMode.value = false;
			} catch (err) {
				unexpectedError(err);
			} finally {
				saving.value = false;
			}
		}

		async function deletePanel() {
			if (!currentDashboard.value || !confirmDeletePanel.value) return;

			deletingPanel.value = true;

			try {
				if (confirmDeletePanel.value.startsWith('_') === false) {
					await api.delete(`/panels/${confirmDeletePanel.value}`);
					await insightsStore.hydrate();
				}
				stagedPanels.value = stagedPanels.value.filter((panel) => panel.id !== confirmDeletePanel.value);
				confirmDeletePanel.value = null;
			} catch (err) {
				unexpectedError(err);
			} finally {
				deletingPanel.value = false;
			}
		}

		function cancelChanges() {
			stagedPanels.value = [];
			editMode.value = false;
		}

		function duplicatePanel(panel: Panel) {
			const newPanel = omit(merge({}, panel), 'id');
			newPanel.position_x = newPanel.position_x + 2;
			newPanel.position_y = newPanel.position_y + 2;
			stagePanelEdits(newPanel, '+');
		}

		function toggleFullScreen() {
			fullScreen.value = !fullScreen.value;
		}

		function toggleZoomToFit() {
			zoomToFit.value = !zoomToFit.value;
		}
	},
});
</script>

<style scoped>
.fullscreen,
.zoom-to-fit,
.clear-changes {
	--v-button-color: var(--foreground-normal);
	--v-button-color-hover: var(--foreground-normal);
	--v-button-background-color: var(--foreground-subdued);
	--v-button-background-color-hover: var(--foreground-normal);
}
</style>
